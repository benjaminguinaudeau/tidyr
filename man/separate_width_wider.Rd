% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/separate2.R
\name{separate_width_wider}
\alias{separate_width_wider}
\alias{separate_width_longer}
\title{Separate a character column by widths}
\usage{
separate_width_wider(data, cols, widths, names_sep = NULL)

separate_width_longer(data, cols, width, keep_empty = FALSE)
}
\arguments{
\item{data}{A data frame.}

\item{cols}{String columns to separate into pieces. If neeeded, you can use
tidyselect to multiple columns.}

\item{widths}{A named numeric vector where the names become column names,
and the values specify the column width. Omit the name to leave those
values out of the final output.}

\item{names_sep}{If \code{NULL}, the default, the names will be left
as is. If a string, the outer and inner names will be pasted together using
\code{names_sep} as a separator.

If the values being unnested are unnamed and \code{names_sep} is supplied, the
inner names will be automatically generated as an increasing sequence of
integers.}

\item{width}{Number of characters to split by.}

\item{keep_empty}{By default, you'll get \code{nchar(x) / width} rows for
each observation. If \code{nchar(x)} is zero, this means the entire input
row will be dropped from the output. If you want to preserve all rows,
use \code{keep_empty = TRUE} to replace size-0 elements with a missing value.}
}
\description{
Separate a character column by widths
}
\examples{
df <- tibble(id = 1:2, x = c("m-123", "f-455"))
df \%>\% separate_width_wider(x, c(gender = 1, 1, unit = 3, test = 2))

df <- tibble(id = 1:3, x = c("ab", "def", ""))
df \%>\% separate_width_longer(x, 1)
df \%>\% separate_width_longer(x, 2)
}
