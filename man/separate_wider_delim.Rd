% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/separate-wider.R
\name{separate_wider_delim}
\alias{separate_wider_delim}
\alias{separate_wider_fixed}
\alias{separate_wider_regex}
\title{Split a string into columns}
\usage{
separate_wider_delim(
  data,
  cols,
  delim,
  names = NULL,
  names_sep = NULL,
  extra = c("warn", "drop", "merge"),
  fill = c("warn", "right", "left"),
  names_repair = "check_unique"
)

separate_wider_fixed(
  data,
  cols,
  widths,
  names_sep = NULL,
  names_repair = "check_unique"
)

separate_wider_regex(
  data,
  cols,
  patterns,
  match_complete = TRUE,
  names_sep = NULL,
  names_repair = "check_unique"
)
}
\arguments{
\item{data}{A data frame.}

\item{cols}{String columns to separate into pieces. If needed, you can use
tidyselect to multiple columns.}

\item{delim}{Delimiter between columns, a stringr pattern.

Note that the default is a regular expression so that \code{delim = "."} will
split on every character. If you need to split by a special character, you
can use \code{delim = stringr::fixed(".")}.}

\item{names, names_sep}{Specify either either a fixed number of column
\code{names} or use \code{names_sep} to generate new names from the source column
name and a numeric suffix.}

\item{extra}{If \code{sep} is a character vector, this controls what
happens when there are too many pieces. There are three valid options:
\itemize{
\item "warn" (the default): emit a warning and drop extra values.
\item "drop": drop any extra values without a warning.
\item "merge": only splits at most \code{length(into)} times
}}

\item{fill}{If \code{sep} is a character vector, this controls what
happens when there are not enough pieces. There are three valid options:
\itemize{
\item "warn" (the default): emit a warning and fill from the right
\item "right": fill with missing values on the right
\item "left": fill with missing values on the left
}}

\item{names_repair}{Used to check that output data frame has valid
names. Must be one of the following options:
\itemize{
\item "minimal": no name repair or checks, beyond basic existence,
\item "unique": make sure names are unique and not empty,
\item "check_unique": (the default), no name repair, but check they are unique,
\item "universal": make the names unique and syntactic
\item a function: apply custom name repair.
\item \link{tidyr_legacy}: use the name repair from tidyr 0.8.
\item a formula: a purrr-style anonymous function (see \code{\link[rlang:as_function]{rlang::as_function()}})
}

See \code{\link[vctrs:vec_as_names]{vctrs::vec_as_names()}} for more details on these terms and the
strategies used to enforce them.}

\item{widths}{A named numeric vector where the names become column names,
and the values specify the column width. Omit the name to leave those
values out of the final output.}

\item{patterns}{A named character vector where the names given names of
new columns in the output, and the values are regular expressions.
Unnamed components will match, but not be included in the output.}

\item{match_complete}{Is the pattern required to match the entire string?}
}
\description{
\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#experimental}{\figure{lifecycle-experimental.svg}{options: alt='[Experimental]'}}}{\strong{[Experimental]}}

Each of these functions takes a string column and splits it into multiple
new columns:
\itemize{
\item \code{separate_wider_delim()} splits with a delimiter.
\item \code{separate_wider_fixed()} splits using fixed widths.
\item \code{separate_wider_regex()} splits using regular expression matches.
}

These functions are equivalent to \code{\link[=separate]{separate()}} and \code{\link[=extract]{extract()}}.  but use
\href{http://stringr.tidyverse.org/}{stringr} as the underlying string
manipulation engine, and their interfaces reflect what we've learned from
\code{\link[=unnest_wider]{unnest_wider()}} and \code{\link[=unnest_longer]{unnest_longer()}}.
}
\examples{
df <- tibble(id = 1:2, x = c("m-123", "f-455"))
# There are three basic ways to split up a string into pieces.
# * with a delimiter
df \%>\% separate_wider_delim(x, delim = "-", c("gender", "unit"))
# * by length
df \%>\% separate_wider_fixed(x, c(gender = 1, 1, unit = 3))
# * defining each component with a regular expression
df \%>\% separate_wider_regex(x, c(gender = ".", ".", unit = "\\\\d+"))

# Sometimes you split on the "last" delimiter:
df <- data.frame(var = c("race_1", "race_2", "age_bucket_1", "age_bucket_2"))
# _delim won't help because it always splits on the first delimiter
df \%>\% separate_wider_delim(var, "_", names = c("var1", "var2"), extra = "merge")
# Instead, you can use _regex:
df \%>\% separate_wider_regex(var, c(var1 = ".*", "_", var2 = ".*"))

# If the number of components varies, it's most natural to split into rows
df <- tibble(id = 1:4, x = c("x", "x y", "x y z", NA))
df \%>\% separate_longer_delim(x, delim = " ")
# But separate_wider_delim() provides some tools to deal with the problem
# The default behaviour tells you where the problems lie:
df \%>\% separate_wider_delim(x, delim = " ", names = c("a", "b"))
# You can suppress the warnings by setting extra and fill
df \%>\% separate_wider_delim(x, c("a", "b"), delim = " ", extra = "drop", fill = "right")
# Or choose to handle differently
df \%>\% separate_wider_delim(x, c("a", "b"), delim = " ", extra = "merge", fill = "left")
# Or automatically name the columns
#' df \%>\% separate_wider_delim(x, delim = " ", names_sep = "", fill = "right")
}
