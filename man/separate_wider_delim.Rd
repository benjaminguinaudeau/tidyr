% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/separate2.R
\name{separate_wider_delim}
\alias{separate_wider_delim}
\alias{separate_wider_fixed}
\alias{separate_wider_regex}
\title{Split a string into columns}
\usage{
separate_wider_delim(
  data,
  cols,
  into,
  delim,
  extra = c("warn", "drop", "merge"),
  fill = c("warn", "right", "left"),
  names_sep = NULL
)

separate_wider_fixed(data, cols, widths, names_sep = NULL)

separate_wider_regex(
  data,
  cols,
  patterns,
  match_complete = TRUE,
  names_sep = NULL
)
}
\arguments{
\item{data}{A data frame.}

\item{cols}{String columns to separate into pieces. If needed, you can use
tidyselect to multiple columns.}

\item{into}{Names of new variables to create as character vector.
Use \code{NA} to omit the variable in the output.}

\item{delim}{Delimiter between columns, a stringr pattern.

Note that the default is a regular expression so that \code{delim = "."} will
split on every character. If you need to split by a special character, you
can use \code{delim = stringr::fixed(".")}.}

\item{extra}{If \code{sep} is a character vector, this controls what
happens when there are too many pieces. There are three valid options:
\itemize{
\item "warn" (the default): emit a warning and drop extra values.
\item "drop": drop any extra values without a warning.
\item "merge": only splits at most \code{length(into)} times
}}

\item{fill}{If \code{sep} is a character vector, this controls what
happens when there are not enough pieces. There are three valid options:
\itemize{
\item "warn" (the default): emit a warning and fill from the right
\item "right": fill with missing values on the right
\item "left": fill with missing values on the left
}}

\item{names_sep}{If \code{NULL}, the default, the names will be left
as is. If a string, the outer and inner names will be pasted together using
\code{names_sep} as a separator.

If the values being unnested are unnamed and \code{names_sep} is supplied, the
inner names will be automatically generated as an increasing sequence of
integers.}

\item{widths}{A named numeric vector where the names become column names,
and the values specify the column width. Omit the name to leave those
values out of the final output.}

\item{patterns}{A named character vector where the names given names of
new columns in the output, and the values are regular expressions.
Unnamed components will match, but not be included in the output.}

\item{match_complete}{Is the pattern required to match the entire string?}
}
\description{
\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#experimental}{\figure{lifecycle-experimental.svg}{options: alt='[Experimental]'}}}{\strong{[Experimental]}}

Each of these functions takes a string column and splits it into multiple
new columns:
\itemize{
\item \code{separate_wider_delim()} splits with a delimiter.
\item \code{separate_wider_fixed()} splits using fixed widths.
\item \code{separate_wider_regex()} splits using regular expression matches.
}

These functions are equivalent to \code{\link[=separate]{separate()}} and \code{\link[=extract]{extract()}}.  but use
\href{http://stringr.tidyverse.org/}{stringr} as the underlying string
manipulation engine, and their interfaces reflect what we've learned from
\code{\link[=unnest_wider]{unnest_wider()}} and \code{\link[=unnest_longer]{unnest_longer()}}.
}
\examples{
df <- tibble(id = 1:2, x = c("m-123", "f-455"))
# There are three basic ways to split up a string into pieces.
# * with a delimiter
df \%>\% separate_wider_delim(x, c("gender", "unit"), delim = "-")
# * by length
df \%>\% separate_wider_fixed(x, c(gender = 1, 1, unit = 3))
# * defining each component with a regular expression
df \%>\% separate_wider_regex(x, c(gender = ".", ".", unit = "\\\\d+"))

# If the number of components varies, it's most natural to split into rows
df <- tibble(id = 1:4, x = c("x", "x y", "x y z", NA))
df \%>\% separate_longer_delim(x, delim = " ")
# But separate_wider_delim() provides some tools to deal with the problem
# The default behaviour tells you where the problems lie:
df \%>\% separate_wider_delim(x, c("a", "b"), delim = " ")
# You can suppress the warnings by setting extra and fill
df \%>\% separate_wider_delim(x, c("a", "b"), delim = " ", extra = "drop", fill = "right")
# Or choose to handle differently
df \%>\% separate_wider_delim(x, c("a", "b"), delim = " ", extra = "merge", fill = "left")
}
