% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/separate2.R
\name{separate_wider_delim}
\alias{separate_wider_delim}
\alias{separate_wider_fixed}
\alias{separate_wider_regex}
\title{Split a string into columns}
\usage{
separate_wider_delim(
  data,
  cols,
  into,
  delim,
  extra = c("warn", "drop", "merge"),
  fill = c("warn", "right", "left"),
  names_sep = NULL
)

separate_wider_fixed(data, cols, widths, names_sep = NULL)

separate_wider_regex(
  data,
  cols,
  patterns,
  match_complete = TRUE,
  names_sep = NULL
)
}
\arguments{
\item{data}{A data frame.}

\item{cols}{String columns to separate into pieces. If neeeded, you can use
tidyselect to multiple columns.}

\item{into}{Names of new variables to create as character vector.
Use \code{NA} to omit the variable in the output.}

\item{delim}{Delimer between columns, a stringr regular expression.}

\item{extra}{If \code{sep} is a character vector, this controls what
happens when there are too many pieces. There are three valid options:
\itemize{
\item "warn" (the default): emit a warning and drop extra values.
\item "drop": drop any extra values without a warning.
\item "merge": only splits at most \code{length(into)} times
}}

\item{fill}{If \code{sep} is a character vector, this controls what
happens when there are not enough pieces. There are three valid options:
\itemize{
\item "warn" (the default): emit a warning and fill from the right
\item "right": fill with missing values on the right
\item "left": fill with missing values on the left
}}

\item{names_sep}{If \code{NULL}, the default, the names will be left
as is. If a string, the outer and inner names will be pasted together using
\code{names_sep} as a separator.

If the values being unnested are unnamed and \code{names_sep} is supplied, the
inner names will be automatically generated as an increasing sequence of
integers.}

\item{widths}{A named numeric vector where the names become column names,
and the values specify the column width. Omit the name to leave those
values out of the final output.}

\item{patterns}{A named character vector where the names given names of
new columns in the output, and the values are regular expressions.
Unnamed components will match, but not be included in the output.}

\item{match_complete}{Is the pattern required to match the entire string?}
}
\description{
\itemize{
\item \code{separate_wider_delim()} splits with a delimiter.
\item \code{separate_wider_fixed()} splits using fixed widths.
\item \code{separate_wider_regex()} splits using regular expression matches.
}
}
\examples{
# If the number of components varies, it's most natural to split into rows
df <- tibble(id = 1:4, x = c("x", "x y", "x y z", NA))
# But it's still possible to split into columns
df \%>\% separate_wider_delim(x, c("a", "b"), delim = " ")
# You can suppress the warnings by setting extra and fill
df \%>\% separate_wider_delim(x, c("a", "b"), delim = " ", extra = "drop", fill = "right")

df <- tibble(id = 1:2, x = c("m-123", "f-455"))
df \%>\% separate_wider_fixed(x, c(gender = 1, 1, unit = 3, test = 2))

df <- tibble(id = 1:2, x = c("m-123", "f_4559"))
df \%>\% separate_wider_regex(x, c(gender = ".", ".", unit = "\\\\d+"))
}
